Fst
Fst(mys, pop_assignments)
save(mys, "tests/testthat/testdata/mys.RData")
save(mys, file = "tests/testthat/testdata/mys.RData")
save(dav, file = "tests/testthat/testdata/dav.RData")
ExpectedHeterozygosity()
load("testdata/mys.RData")
load("tests/testdata/mys.RData")
load("tests/testthat/testdata/mys.RData")
ExpectedHeterozygosity(mys)
ObservedHeterozygosity()
ObservedHeterozygosity(mys)
SegregatingSites(mys)
SingeltonSites(mys)
TajimasD(mys)
TajimasD(mys, 265392)
devtools::document()
TajimasD(mys, 265392)
devtools::document()
mys@missing_data
devtools::document()
mys@missing_data
devtools::document()
library(tools)
Rd2pdf
Rd2pdf()
Rd2latex("man/*")
Rd2latex("man/*.Rd")
Rd2latex("man/calculateAlleleFreqs.Rd")
Rd2latex("man/GenoPop.Rd)
Rd2latex("man/GenoPop.Rd")
devtools::load_all()
calculateAlleleFreqs()
class(mys)
library(GenoPop)
devtools::check()
devtools::check()
library(GenoPop)
library(GenoPop)
devtools::load_all()
data(mys)
imputeMissingData(mys, method = "kNN")
# Read vcf
vcf <- read.vcfR("/home/mick/Desktop/gp_testing/vcfs/sim84.vcf.gz")
library(GenoPop)
# Read vcf
vcf <- read.vcfR("/home/mick/Desktop/gp_testing/vcfs/sim84.vcf.gz")
library(vcfR
)
# Read vcf
vcf <- read.vcfR("/home/mick/Desktop/gp_testing/vcfs/sim84.vcf.gz")
devtools::load_all()
data(sim)
sim <- calculateAlleleFreqs(sim)
test <- add_mcar(sim, 0.05)
library(GenoPop)
### Function to introduce missing values into genotype matrix (MCAR) ###
add_mcar <- function(object, proportion) {
total_entries <- nrow(object@sep_gt) * ncol(object@sep_gt)
num_missing <- round(total_entries * proportion) # 5% of total entries
# Generating random indices to introduce missing data
missing_indices <- sample(total_entries, num_missing, replace = FALSE)
# Convert linear indices to matrix indices
missing_rows <- (missing_indices - 1) %/% ncol(object@sep_gt) + 1
missing_cols <- (missing_indices - 1) %% ncol(object@sep_gt) + 1
# Setting these indices to missing (".")
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
# Run this function wihtout removin anything to update the missing data slot.
object <- rmMissingData(object, 1)
return(object)
}
### Function to calculate imputation quality metrics ###
# Quality metrics are:
# 1. Proportion of correctly imputed entries
# 2. Root Mean Squared Error (RMSE): This measures the average squared difference between the imputed values and the actual values. Lower RMSE values indicate better imputation accuracy.
# 3. Mean Absolute Error (MAE): This metric calculates the average absolute difference between the imputed and actual values. Similar to RMSE, lower MAE values signify more accurate imputations.
# Lastly, it will give the quality metrics for a random imputation done on the same data set to be able to compare imputation methods to random imputed values.
evaluate_imputation <- function(original_vcfR, imputed_vcfR) {
original_matrix <- original_vcfR@sep_gt
imputed_matrix <- imputed_vcfR@imp_gt
introduced_missing_matrix <- imputed_vcfR@sep_gt
missing_indices <- which(introduced_missing_matrix == ".", arr.ind = TRUE)
# Real imputation Metrics
imputed_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(imputed_matrix[missing_indices])
imputed_rmse <- sqrt(mean(imputed_errors^2))
imputed_mae <- mean(abs(imputed_errors))
imputed_correct_proportion <- mean(original_matrix[missing_indices] == imputed_matrix[missing_indices])
# Random Imputation
random_imputation <- introduced_missing_matrix # Copy matrix with missing data
for (idx in 1:nrow(missing_indices)) {
random_imputation[missing_indices[idx, "row"], missing_indices[idx, "col"]] <- sample(c("0", "1"), 1)
}
# Random Imputation Metrics
random_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(random_imputation[missing_indices])
random_rmse <- sqrt(mean(random_errors^2, na.rm = TRUE))
random_mae <- mean(abs(random_errors), na.rm = TRUE)
random_correct_proportion <- mean(original_matrix[missing_indices] == random_imputation[missing_indices], na.rm = TRUE)
# Return the results
return(list(imputed_rmse = imputed_rmse, imputed_mae = imputed_mae, imputed_correct_proportion = imputed_correct_proportion,
random_rmse = random_rmse, random_mae = random_mae, random_correct_proportion = random_correct_proportion))
}
devtools::load_all()
test <- add_mcar(sim, 0.05)
test <- imputeMissingData(test, method = "kNN")
devtools::load_all()
devtools::load_all()
test <- imputeMissingData(test, method = "kNN")
test <- imputeMissingData(test, method = "kNN", threads = 2)
res <- evaluate_imputation(sim, test)
res
library(GenoPop)
devtools::load_all()
test <- add_mcar(sim, 0.05)
test <- imputeMissingData(test, method = "kNN", threads = 2)
res <- evaluate_imputation(sim, test)
res
View(test@imp_gt)
is.na.data.frame(test@imp_gt)
is.na(test@imp_gt)
which(is.na(test@imp_gt))
### Function to calculate imputation quality metrics ###
# Quality metrics are:
# 1. Proportion of correctly imputed entries
# 2. Root Mean Squared Error (RMSE): This measures the average squared difference between the imputed values and the actual values. Lower RMSE values indicate better imputation accuracy.
# 3. Mean Absolute Error (MAE): This metric calculates the average absolute difference between the imputed and actual values. Similar to RMSE, lower MAE values signify more accurate imputations.
# Lastly, it will give the quality metrics for a random imputation done on the same data set to be able to compare imputation methods to random imputed values.
evaluate_imputation <- function(original_vcfR, imputed_vcfR) {
original_matrix <- original_vcfR@sep_gt
imputed_matrix <- imputed_vcfR@imp_gt
introduced_missing_matrix <- imputed_vcfR@sep_gt
missing_indices <- which(introduced_missing_matrix == ".", arr.ind = TRUE)
# Real imputation Metrics
imputed_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(imputed_matrix[missing_indices])
imputed_rmse <- sqrt(mean(imputed_errors^2, na.rm = TRUE))
imputed_mae <- mean(abs(imputed_errors), na.rm = TRUE)
imputed_correct_proportion <- mean(original_matrix[missing_indices] == imputed_matrix[missing_indices])
# Random Imputation
random_imputation <- introduced_missing_matrix # Copy matrix with missing data
for (idx in 1:nrow(missing_indices)) {
random_imputation[missing_indices[idx, "row"], missing_indices[idx, "col"]] <- sample(c("0", "1"), 1)
}
# Random Imputation Metrics
random_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(random_imputation[missing_indices])
random_rmse <- sqrt(mean(random_errors^2, na.rm = TRUE))
random_mae <- mean(abs(random_errors), na.rm = TRUE)
random_correct_proportion <- mean(original_matrix[missing_indices] == random_imputation[missing_indices], na.rm = TRUE)
# Return the results
return(list(imputed_rmse = imputed_rmse, imputed_mae = imputed_mae, imputed_correct_proportion = imputed_correct_proportion,
random_rmse = random_rmse, random_mae = random_mae, random_correct_proportion = random_correct_proportion))
}
res <- evaluate_imputation(sim, test)
res
test <- add_mcar(sim, 0.05)
test <- imputeMissingData(test, method = "rf", threads = 2)
devtools::load_all()
test <- imputeMissingData(test, method = "rf", threads = 2)
devtools::load_all()
test <- imputeMissingData(test, method = "rf", threads = 2)
res <- evaluate_imputation(sim, test)
res
print(res)
# Read vcf
vcf <- read.vcfR("/home/mick/Desktop/gp_testing/vcfs/sim84.vcf.gz")
sim <- calculateAlleleFreqs(vcf)
test <- add_mcar(sim, 0.05)
test <- imputeMissingData(test, method = "mean", mode = "individual")
res <- evaluate_imputation(sim, test)
res
?kNNImputation
?rfImputation
library(vcfR)
?read.vcfR
devtools::load_all()
data(sim)
sim <- calculateAlleleFreqs(sim)
read.vcfR
?.read_body_gz
.read_body_gz
# Function to process and evaluate a single VCF file
process_vcf <- function(vcf_path) {
vcf <- read.vcfR(vcf_path)
sim <- calculatePloidyAndSepGT(vcf)
test <- add_mcar(sim, 0.05)
test <- imputeMissingData(test, method = "mean", mode = "individual")
evaluate_imputation(sim, test)
}
library(GenoPop)
library(vcfR)
### Function to introduce missing values into genotype matrix (MCAR) ###
add_mcar <- function(object, proportion) {
total_entries <- nrow(object@sep_gt) * ncol(object@sep_gt)
num_missing <- round(total_entries * proportion) # 5% of total entries
# Generating random indices to introduce missing data
missing_indices <- sample(total_entries, num_missing, replace = FALSE)
# Convert linear indices to matrix indices
missing_rows <- (missing_indices - 1) %/% ncol(object@sep_gt) + 1
missing_cols <- (missing_indices - 1) %% ncol(object@sep_gt) + 1
# Setting these indices to missing (".")
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
# Run this function wihtout removin anything to update the missing data slot.
object <- rmMissingData(object, 1)
return(object)
}
### Function to calculate imputation quality metrics ###
# Quality metrics are:
# 1. Proportion of correctly imputed entries
# 2. Root Mean Squared Error (RMSE): This measures the average squared difference between the imputed values and the actual values. Lower RMSE values indicate better imputation accuracy.
# 3. Mean Absolute Error (MAE): This metric calculates the average absolute difference between the imputed and actual values. Similar to RMSE, lower MAE values signify more accurate imputations.
# Lastly, it will give the quality metrics for a random imputation done on the same data set to be able to compare imputation methods to random imputed values.
evaluate_imputation <- function(original_vcfR, imputed_vcfR) {
original_matrix <- original_vcfR@sep_gt
imputed_matrix <- imputed_vcfR@imp_gt
introduced_missing_matrix <- imputed_vcfR@sep_gt
missing_indices <- which(introduced_missing_matrix == ".", arr.ind = TRUE)
# Real imputation Metrics
imputed_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(imputed_matrix[missing_indices])
imputed_rmse <- sqrt(mean(imputed_errors^2, na.rm = TRUE))
imputed_mae <- mean(abs(imputed_errors), na.rm = TRUE)
imputed_correct_proportion <- mean(original_matrix[missing_indices] == imputed_matrix[missing_indices])
# Random Imputation
random_imputation <- introduced_missing_matrix # Copy matrix with missing data
for (idx in 1:nrow(missing_indices)) {
random_imputation[missing_indices[idx, "row"], missing_indices[idx, "col"]] <- sample(c("0", "1"), 1)
}
# Random Imputation Metrics
random_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(random_imputation[missing_indices])
random_rmse <- sqrt(mean(random_errors^2, na.rm = TRUE))
random_mae <- mean(abs(random_errors), na.rm = TRUE)
random_correct_proportion <- mean(original_matrix[missing_indices] == random_imputation[missing_indices], na.rm = TRUE)
# Return the results
return(list(imputed_rmse = imputed_rmse, imputed_mae = imputed_mae, imputed_correct_proportion = imputed_correct_proportion,
random_rmse = random_rmse, random_mae = random_mae, random_correct_proportion = random_correct_proportion))
}
# Function to process and evaluate a single VCF file
process_vcf <- function(vcf_path) {
vcf <- read.vcfR(vcf_path)
sim <- calculatePloidyAndSepGT(vcf)
test <- add_mcar(sim, 0.05)
test <- imputeMissingData(test, method = "mean", mode = "individual")
evaluate_imputation(sim, test)
}
# List all VCF files in the folder
vcf_files <- list.files("/home/mick/Desktop/gp_testing/bla", pattern = "\\.vcf(\\.gz)?$", full.names = TRUE)
# Process and evaluate each VCF file
results <- lapply(vcf_files, process_vcf)
### Function to introduce missing values into genotype matrix (MCAR) ###
add_mcar <- function(object, proportion) {
total_entries <- nrow(object@sep_gt) * ncol(object@sep_gt)
num_missing <- round(total_entries * proportion) # 5% of total entries
# Generating random indices to introduce missing data
missing_indices <- sample(total_entries, num_missing, replace = FALSE)
# Convert linear indices to matrix indices
missing_rows <- (missing_indices - 1) %/% ncol(object@sep_gt) + 1
missing_cols <- (missing_indices - 1) %% ncol(object@sep_gt) + 1
# Setting these indices to missing (".")
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
# Run this function wihtout removin anything to update the missing data slot.
# object <- rmMissingData(object, 1)
return(object)
}
### Function to calculate imputation quality metrics ###
# Quality metrics are:
# 1. Proportion of correctly imputed entries
# 2. Root Mean Squared Error (RMSE): This measures the average squared difference between the imputed values and the actual values. Lower RMSE values indicate better imputation accuracy.
# 3. Mean Absolute Error (MAE): This metric calculates the average absolute difference between the imputed and actual values. Similar to RMSE, lower MAE values signify more accurate imputations.
# Lastly, it will give the quality metrics for a random imputation done on the same data set to be able to compare imputation methods to random imputed values.
evaluate_imputation <- function(original_vcfR, imputed_vcfR) {
original_matrix <- original_vcfR@sep_gt
imputed_matrix <- imputed_vcfR@imp_gt
introduced_missing_matrix <- imputed_vcfR@sep_gt
missing_indices <- which(introduced_missing_matrix == ".", arr.ind = TRUE)
# Real imputation Metrics
imputed_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(imputed_matrix[missing_indices])
imputed_rmse <- sqrt(mean(imputed_errors^2, na.rm = TRUE))
imputed_mae <- mean(abs(imputed_errors), na.rm = TRUE)
imputed_correct_proportion <- mean(original_matrix[missing_indices] == imputed_matrix[missing_indices])
# Random Imputation
random_imputation <- introduced_missing_matrix # Copy matrix with missing data
for (idx in 1:nrow(missing_indices)) {
random_imputation[missing_indices[idx, "row"], missing_indices[idx, "col"]] <- sample(c("0", "1"), 1)
}
# Random Imputation Metrics
random_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(random_imputation[missing_indices])
random_rmse <- sqrt(mean(random_errors^2, na.rm = TRUE))
random_mae <- mean(abs(random_errors), na.rm = TRUE)
random_correct_proportion <- mean(original_matrix[missing_indices] == random_imputation[missing_indices], na.rm = TRUE)
# Return the results
return(list(imputed_rmse = imputed_rmse, imputed_mae = imputed_mae, imputed_correct_proportion = imputed_correct_proportion,
random_rmse = random_rmse, random_mae = random_mae, random_correct_proportion = random_correct_proportion))
}
# Function to process and evaluate a single VCF file
process_vcf <- function(vcf_path) {
vcf <- read.vcfR(vcf_path)
sim <- calculatePloidyAndSepGT(vcf)
test <- add_mcar(sim, 0.05)
test <- imputeMissingData(test, method = "mean", mode = "individual")
evaluate_imputation(sim, test)
}
# List all VCF files in the folder
vcf_files <- list.files("/home/mick/Desktop/gp_testing/bla", pattern = "\\.vcf(\\.gz)?$", full.names = TRUE)
# Process and evaluate each VCF file
results <- lapply(vcf_files, process_vcf)
# Convert the list of results to a dataframe
results_df <- do.call(rbind, lapply(results, as.data.frame))
results_df$File <- basename(vcf_files) # Add file names as a new column
# Reorder columns to make 'File' the first column
results_df <- results_df[, c("File", setdiff(names(results_df), "File"))]
View(results_df)
sim
library(GenoPop)
library(vcfR)
### Function to introduce missing values into genotype matrix (MCAR) ###
add_mcar <- function(object, proportion) {
total_entries <- nrow(object@sep_gt) * ncol(object@sep_gt)
num_missing <- round(total_entries * proportion) # 5% of total entries
# Generating random indices to introduce missing data
missing_indices <- sample(total_entries, num_missing, replace = FALSE)
# Convert linear indices to matrix indices
missing_rows <- (missing_indices - 1) %/% ncol(object@sep_gt) + 1
missing_cols <- (missing_indices - 1) %% ncol(object@sep_gt) + 1
# Setting these indices to missing (".")
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
# Run this function wihtout removin anything to update the missing data slot.
# object <- rmMissingData(object, 1)
return(object)
}
### Function to calculate imputation quality metrics ###
# Quality metrics are:
# 1. Proportion of correctly imputed entries
# 2. Root Mean Squared Error (RMSE): This measures the average squared difference between the imputed values and the actual values. Lower RMSE values indicate better imputation accuracy.
# 3. Mean Absolute Error (MAE): This metric calculates the average absolute difference between the imputed and actual values. Similar to RMSE, lower MAE values signify more accurate imputations.
# Lastly, it will give the quality metrics for a random imputation done on the same data set to be able to compare imputation methods to random imputed values.
evaluate_imputation <- function(original_vcfR, imputed_vcfR) {
original_matrix <- original_vcfR@sep_gt
imputed_matrix <- imputed_vcfR@imp_gt
introduced_missing_matrix <- imputed_vcfR@sep_gt
missing_indices <- which(introduced_missing_matrix == ".", arr.ind = TRUE)
# Real imputation Metrics
imputed_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(imputed_matrix[missing_indices])
imputed_rmse <- sqrt(mean(imputed_errors^2, na.rm = TRUE))
imputed_mae <- mean(abs(imputed_errors), na.rm = TRUE)
imputed_correct_proportion <- mean(original_matrix[missing_indices] == imputed_matrix[missing_indices])
# Random Imputation
random_imputation <- introduced_missing_matrix # Copy matrix with missing data
for (idx in 1:nrow(missing_indices)) {
random_imputation[missing_indices[idx, "row"], missing_indices[idx, "col"]] <- sample(c("0", "1"), 1)
}
# Random Imputation Metrics
random_errors <- as.numeric(original_matrix[missing_indices]) - as.numeric(random_imputation[missing_indices])
random_rmse <- sqrt(mean(random_errors^2, na.rm = TRUE))
random_mae <- mean(abs(random_errors), na.rm = TRUE)
random_correct_proportion <- mean(original_matrix[missing_indices] == random_imputation[missing_indices], na.rm = TRUE)
# Return the results
return(list(imputed_rmse = imputed_rmse, imputed_mae = imputed_mae, imputed_correct_proportion = imputed_correct_proportion,
random_rmse = random_rmse, random_mae = random_mae, random_correct_proportion = random_correct_proportion))
}
sim@meta
# Function to process and evaluate a single VCF file
process_vcf <- function(vcf_path) {
message(paste0("Processing: ", vcf_path))
vcf <- read.vcfR(vcf_path)
sim <- calculatePloidyAndSepGT(vcf)
test <- add_mcar(sim, 0.05)
test <- imputeMissingData(test, method = "mean", mode = "individual")
evaluate_imputation(sim, test)
}
# List all VCF files in the folder
vcf_files <- list.files("/home/mick/Desktop/gp_testing/bla", pattern = "\\.vcf(\\.gz)?$", full.names = TRUE)
# Process and evaluate each VCF file
results <- lapply(vcf_files, process_vcf)
sim
vcf <- "/home/mick/Desktop/gp_testing/bla/sim30.vcf.gz"
vcf <- read.vcfR(vcf)
sim <- calculatePloidyAndSepGT(vcf)
sim@meta
sim@allele_freqs
output_path <- "/scratch/mgurke/GenoPop_testing/tests/initial_large/mean/results/sim13.vcf.gz.Rdata.tsv"
gsub(".tsv", "", output_path)
library(GenoPop)
file <- "~/Desktop/gp_testing/sim1.vcf.gz.Rdata"
load(file)
sim_data@
sim_data
sim_data@sep_gt
data <- calculateAlleleFreqs(sim_data)
data@ploidy
data@imp_gt
data@allele_freqs
View(data@sep_gt)
head(data@allele_freqs)
head(data@sep_gt)
head(data@allele_freqs)
View(data@allele_freqs)
library(vcfR)
vcf <- read.vcfR("~/Desktop/gp_testing/vcfs/sim1.vcf.gz", nrows = 100000)
View(vcf@gt)
vcf <- read.vcfR("~/Desktop/gp_testing/vcfs/sim2.vcf.gz", nrows = 100000)
View(vcf@gt)
data(real)
View(real@gt)
r <- calculateAlleleFreqs(real)
View(r@gt)
View(r@sep_gt)
data(dav)
View(dav@imp_gt)
library(GenoPop)
file <- "~/Desktop/gp_testing/sim1.vcf.gz.Rdata"
load(file)
data <- calculateAlleleFreqs(sim_data)
library(GenoPop)
file <- "~/Desktop/gp_testing/sim1.vcf.gz.Rdata"
load(file)
data <- calculateAlleleFreqs(sim_data)
View(data@allele_freqs)
FixedSites(data)
PolymorphicSites(data)
SegregatingSites(data)
SingeltonSites(data)
ObservedHeterozygosity(data)
Pi(data, sl)
sl <- 33885323
Pi(data, sl)
View(data@sep_gt)
paste0("tsk_", 0:59)
colnames(data@sep_gt)
pop1 <- paste0("tsk_", 0:29)
pop2 <- paste0("tsk_", 30:59)
file <- "~/Desktop/gp_testing/sim1.vcf.gz.Rdata"
sl <- 33885323
pop1 <- paste0("tsk_", 0:29)
pop2 <- paste0("tsk_", 30:59)
individuals <- c(pop1, pop2)
pop_names <- c(rep("pop1", length(pop1)), rep("pop2", length(pop2)))
pop_assignments <- setNames(pop_names, individuals)
sep <- separateByPopulations(data, pop_assignments)
pop_assignments
sep <- separateByPopulations(data, pop_assignments)
matrix(nrow = 1, ncol = 60)
colnames(gt) <- c(pop1, pop2)
gt <- matrix(nrow = 1, ncol = 60)
colnames(gt) <- c(pop1, pop2)
gt
data@gt <- gt
sep <- separateByPopulations(data, pop_assignments)
data@ploidy
ncol(gt)
gt_pop <- matrix(nrow = 1, ncol = 60)
colnames(gt_pop) <- c(pop1, pop2)
rep(1:object@ploidy, times = ncol(gt_pop)),
rep(colnames(gt_pop), each = object@ploidy)
object <- data
rep(colnames(gt_pop), each = object@ploidy)
rep(1:object@ploidy, times = ncol(gt_pop))
library(GenoPop)
file <- "~/Desktop/gp_testing/sim1.vcf.gz.Rdata"
sl <- 33885323
pop1 <- paste0("tsk_", 0:29)
pop2 <- paste0("tsk_", 30:59)
individuals <- c(pop1, pop2)
pop_names <- c(rep("pop1", length(pop1)), rep("pop2", length(pop2)))
pop_assignments <- setNames(pop_names, individuals)
gt_pop <- matrix(nrow = 1, ncol = 60)
colnames(gt_pop) <- c(pop1, pop2)
load(file)
data <- calculateAlleleFreqs(sim_data)
data@gt <- gt_pop
sep <- separateByPopulations(data, pop_assignments)
data@gt
data@gt[, pop1]
data@gt[, pop2]
gt_pop <- data@gt[, pop1]
rep(colnames(gt_pop), each = object@ploidy)
gt_pop
library(GenoPop)
file <- "~/Desktop/gp_testing/sim1.vcf.gz.Rdata"
sl <- 33885323
pop1 <- paste0("tsk_", 0:29)
pop2 <- paste0("tsk_", 30:59)
individuals <- c(pop1, pop2)
pop_names <- c(rep("pop1", length(pop1)), rep("pop2", length(pop2)))
pop_assignments <- setNames(pop_names, individuals)
gt_pop <- matrix(nrow = 3, ncol = 60)
colnames(gt_pop) <- c(pop1, pop2)
load(file)
data <- calculateAlleleFreqs(sim_data)
gt_pop
data@gt <- gt_pop
sep <- separateByPopulations(data, pop_assignments)
sep <- separateByPopulations(data, pop_assignments, rm_ref_alleles = FALSE)
sep[[1]]
Pi(sep[[1]], sl)
Pi(sep[[2]], sl)
TajimasD(data, sl)
TajimasD(sep[[1]], sl)
TajimasD(sep[[2]], sl)
FixedSites(sep[[1]])
FixedSites(sep[[2]])
SegregatingSites(sep[[1]])
SegregatingSites(sep[[2]])
SingeltonSites(sep[[2]])
SingeltonSites(sep[[1]])
ObservedHeterozygosity(sep[[1]])
ObservedHeterozygosity(sep[[2]])
WattersonsTheta(data, sl)
WattersonsTheta(sep[[1]], sl)
WattersonsTheta(sep[[2]], sl)
Dxy(data, pop_assignments, sl)
Fst(data, pop_assignments)
OneDimSFS(data)
OneDimSFS(sep[[1]])
TwoDimSFS(data)
TwoDimSFS(data, pop_assignments)
