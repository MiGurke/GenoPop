Pi_sep1 = Pi(sep[[1]], sl),
Pi_sep2 = Pi(sep[[2]], sl),
TajimasD_data = TajimasD(data, sl),
TajimasD_sep1 = TajimasD(sep[[1]], sl),
TajimasD_sep2 = TajimasD(sep[[2]], sl),
WattersonsTheta_data = WattersonsTheta(data, sl),
WattersonsTheta_sep1 = WattersonsTheta(sep[[1]], sl),
WattersonsTheta_sep2 = WattersonsTheta(sep[[2]], sl),
Dxy = Dxy(data, pop_assignments, sl),
Fst = Fst(data, pop_assignments)
)
# Handle OneDimSFS separately
oneDimSFS_data <- OneDimSFS(data)
oneDimSFS_sep1 <- OneDimSFS(sep[[1]])
oneDimSFS_sep2 <- OneDimSFS(sep[[2]])
# Adding OneDimSFS results to the row
results_row <- c(
results_row,
sapply(oneDimSFS_data, function(x) x),
sapply(oneDimSFS_sep1, function(x) x),
sapply(oneDimSFS_sep2, function(x) x)
)
# Append the row to the results dataframe
results_df <- rbind(results_df, as.data.frame(t(results_row), stringsAsFactors = FALSE))
results_df
# Extracting results for each function and adding them to the results_row
results_row <- c(
file = basename(file),
FixedSites_data = FixedSites(data),
FixedSites_sep1 = FixedSites(sep[[1]]),
FixedSites_sep2 = FixedSites(sep[[2]]),
SegregatingSites_data = SegregatingSites(data),
SegregatingSites_sep1 = SegregatingSites(sep[[1]]),
SegregatingSites_sep2 = SegregatingSites(sep[[2]]),
SingeltonSites_data = SingeltonSites(data),
SingeltonSites_sep1 = SingeltonSites(sep[[1]]),
SingeltonSites_sep2 = SingeltonSites(sep[[2]]),
ObservedHeterozygosity_data = ObservedHeterozygosity(data),
ObservedHeterozygosity_sep1 = ObservedHeterozygosity(sep[[1]]),
ObservedHeterozygosity_sep2 = ObservedHeterozygosity(sep[[2]]),
Pi_data = Pi(data, sl),
Pi_sep1 = Pi(sep[[1]], sl),
Pi_sep2 = Pi(sep[[2]], sl),
TajimasD_data = TajimasD(data, sl),
TajimasD_sep1 = TajimasD(sep[[1]], sl),
TajimasD_sep2 = TajimasD(sep[[2]], sl),
WattersonsTheta_data = WattersonsTheta(data, sl),
WattersonsTheta_sep1 = WattersonsTheta(sep[[1]], sl),
WattersonsTheta_sep2 = WattersonsTheta(sep[[2]], sl),
Dxy = Dxy(data, pop_assignments, sl),
Fst = Fst(data, pop_assignments)
)
# Additional columns for OneDimSFS
for (i in 1:61) {
results_df[[paste0("OneDimSFS_data_", i)]] <- numeric()
}
# Initialize the results dataframe with columns for each metric
results_df <- data.frame(
file = character(),
FixedSites_data = numeric(),
FixedSites_sep1 = numeric(),
FixedSites_sep2 = numeric(),
SegregatingSites_data = numeric(),
SegregatingSites_sep1 = numeric(),
SegregatingSites_sep2 = numeric(),
SingeltonSites_data = numeric(),
SingeltonSites_sep1 = numeric(),
SingeltonSites_sep2 = numeric(),
ObservedHeterozygosity_data = numeric(),
ObservedHeterozygosity_sep1 = numeric(),
ObservedHeterozygosity_sep2 = numeric(),
Pi_data = numeric(),
Pi_sep1 = numeric(),
Pi_sep2 = numeric(),
TajimasD_data = numeric(),
TajimasD_sep1 = numeric(),
TajimasD_sep2 = numeric(),
WattersonsTheta_data = numeric(),
WattersonsTheta_sep1 = numeric(),
WattersonsTheta_sep2 = numeric(),
Dxy = numeric(),
Fst = numeric(),
stringsAsFactors = FALSE
)
# Add columns for OneDimSFS
for (i in 1:61) {
results_df[[paste0("OneDimSFS_data_", i)]] <- numeric()
}
for (i in 1:31) {
results_df[[paste0("OneDimSFS_sep1_", i)]] <- numeric()
results_df[[paste0("OneDimSFS_sep2_", i)]] <- numeric()
}
sl <- 33885323
pop1 <- paste0("tsk_", 0:29)
pop2 <- paste0("tsk_", 30:59)
individuals <- c(pop1, pop2)
pop_names <- c(rep("pop1", length(pop1)), rep("pop2", length(pop2)))
pop_assignments <- setNames(pop_names, individuals)
data@gt <- gt_pop
sep <- separateByPopulations(data, pop_assignments, rm_ref_alleles = FALSE)
data@sep_gt
# Extracting results for each function and adding them to the results_row
results_row <- c(
file = basename(file),
FixedSites_data = FixedSites(data),
FixedSites_sep1 = FixedSites(sep[[1]]),
FixedSites_sep2 = FixedSites(sep[[2]]),
SegregatingSites_data = SegregatingSites(data),
SegregatingSites_sep1 = SegregatingSites(sep[[1]]),
SegregatingSites_sep2 = SegregatingSites(sep[[2]]),
SingeltonSites_data = SingeltonSites(data),
SingeltonSites_sep1 = SingeltonSites(sep[[1]]),
SingeltonSites_sep2 = SingeltonSites(sep[[2]]),
ObservedHeterozygosity_data = ObservedHeterozygosity(data),
ObservedHeterozygosity_sep1 = ObservedHeterozygosity(sep[[1]]),
ObservedHeterozygosity_sep2 = ObservedHeterozygosity(sep[[2]]),
Pi_data = Pi(data, sl),
Pi_sep1 = Pi(sep[[1]], sl),
Pi_sep2 = Pi(sep[[2]], sl),
TajimasD_data = TajimasD(data, sl),
TajimasD_sep1 = TajimasD(sep[[1]], sl),
TajimasD_sep2 = TajimasD(sep[[2]], sl),
WattersonsTheta_data = WattersonsTheta(data, sl),
WattersonsTheta_sep1 = WattersonsTheta(sep[[1]], sl),
WattersonsTheta_sep2 = WattersonsTheta(sep[[2]], sl),
Dxy = Dxy(data, pop_assignments, sl),
Fst = Fst(data, pop_assignments)
)
# Handle OneDimSFS separately
oneDimSFS_data <- OneDimSFS(data)
oneDimSFS_sep1 <- OneDimSFS(sep[[1]])
oneDimSFS_sep2 <- OneDimSFS(sep[[2]])
# Adding OneDimSFS results to the row
results_row <- c(
results_row,
sapply(oneDimSFS_data, function(x) x),
sapply(oneDimSFS_sep1, function(x) x),
sapply(oneDimSFS_sep2, function(x) x)
)
# Append the row to the results dataframe
results_df <- rbind(results_df, as.data.frame(t(results_row), stringsAsFactors = FALSE))
results_df
data(sim)
s <- calculateAlleleFreqs(sim)
OneDimSFS(s)
barplot(s)
barplot(OneDimSFS(s))
colnames(results_df)
write(colnames(results_df), file = "~/Desktop/gp_testing/pg_mets_colnames.txt")
# Read the sequence length file
#sl_file <- "/scratch/mgurke/GenoPop_testing/sim_data/rdata_100k/sl.tsv"
sl_file <- "~/Desktop/gp_testing/sl.tsv"
sl_data <- read.table(sl_file, header = FALSE, col.names = c("filename", "sl"), stringsAsFactors = FALSE)
# Extract basename without extension for matching
basename_without_ext <- tools::file_path_sans_ext(basename(file))
# Find the sequence length for the current file
sl <- sl_data$sl[sl_data$filename == paste0(basename_without_ext, ".vcf.gz")]
sl
# Find the sequence length for the current file
sl <- sl_data$sl[sl_data$filename == basename_without_ext]
file <- ""
file <- "~/Desktop/gp_testing/sim2.vcf.gz.Rdata"
# Read the sequence length file
#sl_file <- "/scratch/mgurke/GenoPop_testing/sim_data/rdata_100k/sl.tsv"
sl_file <- "~/Desktop/gp_testing/sl.tsv"
sl_data <- read.table(sl_file, header = FALSE, col.names = c("filename", "sl"), stringsAsFactors = FALSE)
# Extract basename without extension for matching
basename_without_ext <- tools::file_path_sans_ext(basename(file))
# Find the sequence length for the current file
sl <- sl_data$sl[sl_data$filename == basename_without_ext]
sl
# Find the sequence length for the current file
sl <- sl_data$sl[sl_data$filename == basename_without_ext]
file <- "~/Desktop/gp_testing/sim13.vcf.gz.Rdata"
# Read the sequence length file
#sl_file <- "/scratch/mgurke/GenoPop_testing/sim_data/rdata_100k/sl.tsv"
sl_file <- "~/Desktop/gp_testing/sl.tsv"
sl_data <- read.table(sl_file, header = FALSE, col.names = c("filename", "sl"), stringsAsFactors = FALSE)
# Extract basename without extension for matching
basename_without_ext <- tools::file_path_sans_ext(basename(file))
# Find the sequence length for the current file
sl <- sl_data$sl[sl_data$filename == basename_without_ext]
sl
sim
s <- calculateAlleleFreqs(sim, missing_data = "impute")
s@imp_gt
matrix()
matrix(ncol = 0, nrow = 0)
s@imp_gt <- # Load necessary library
library(GenoPop)
s@imp_gt <- matrix(ncol = 0, nrow = 0)
s@imp_gt
x <- 1000000
y <- 1000000
x * y
y <- 100000000
x <- 100000000
x * y
x <- 10000000000
y <- 10000000000
x * y
y <- 10000000000000
x <- 10000000000000
x * y
x <- 1000000000000000000000000000000
y <- 1000000000000000000000000000000
x * y
typeof(x)
x <- 1000000
x^2
x^4
x^7
x^9
x^20
x^300
y <- 1000000
x <- as.integer(x)
y <- as.integer(y)
x*y
as.numeric(x) * as.numeric(y)
as.numeric(x) * y
x+y
x*y
load("~/Desktop/gp_testing/sim_ini_s/sim1.vcf.gz.Rdata")
ori <- sim_data
load("~/Desktop/gp_testing/sim_ini_s/sim1_mean.vcf.gz.Rdata")
imp <- test
test@imp_gt <- matrix(ncol = 0, nrow = 0)
mis <- test
o <- OneDimSFS(ori)
m <- OneDimSFS(mis)
i <- OneDimSFS(imp)
devtools::load_all()
o <- OneDimSFS(ori)
m <- OneDimSFS(mis)
i <- OneDimSFS(imp)
identical(i,m)
ObservedHeterozygosity(m)
ObservedHeterozygosity(mis)
ObservedHeterozygosity(imp)
genotype_matrix <- mis@sep_gt
seq(1, ncol(genotype_matrix), by = 2)
x <- c("1",NA)
x
is.na(x)
any(is.na(x))
devtools::load_all()
ObservedHeterozygosity(mis)
devtools::load_all()
ObservedHeterozygosity(mis)
library(GenoPop)
add_mnar <- function(object, missingness_vector) {
# Ensure that the missingness vector is of the same length as the number of individuals
if (length(missingness_vector) != nrow(object@sep_gt)/2) {
stop("The length of the missingness vector must be equal to the number of individuals.")
}
# Number of columns representing each individual (assuming diploid organism, should be 2)
num_chromosomes <- 2
for (i in seq_len(nrow(object@sep_gt)/num_chromosomes)) {
individual_entries <- ncol(object@sep_gt)/num_chromosomes # Number of entries for each chromosome of the individual
num_missing <- round(individual_entries * missingness_vector[i]) # Proportion for this individual
# Generating random indices to introduce missing data for this individual
missing_indices <- sample(individual_entries, num_missing, replace = FALSE)
# Convert these indices to account for the individual's two chromosomes
missing_rows <- rep((i * num_chromosomes - num_chromosomes + 1):(i * num_chromosomes), each = num_missing)
missing_cols <- sort(rep(missing_indices, num_chromosomes))
# Setting these indices to missing (".")
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
}
# Run this function without removing anything to update the missing data slot.
# object <- rmMissingData(object, 1)
return(object)
}
data(sim)
View(sim@gt)
early_scenario <- c(rep(0.05, 5), rep(0.15, 4), rep(0.35, 4), rep(0.65, 2))
s <- calculateAlleleFreqs(sim)
View(add_mnar())
View(add_mnar(s, early_scenario))
# Ensure that the missingness vector is of the same length as the number of individuals
if (length(missingness_vector) != ncol(object@sep_gt)/2) {
stop("The length of the missingness vector must be equal to the number of individuals.")
}
add_mnar <- function(object, missingness_vector) {
# Ensure that the missingness vector is of the same length as the number of individuals
if (length(missingness_vector) != ncol(object@sep_gt)/2) {
stop("The length of the missingness vector must be equal to the number of individuals.")
}
# Number of columns representing each individual (assuming diploid organism, should be 2)
num_chromosomes <- 2
for (i in seq_len(nrow(object@sep_gt)/num_chromosomes)) {
individual_entries <- ncol(object@sep_gt)/num_chromosomes # Number of entries for each chromosome of the individual
num_missing <- round(individual_entries * missingness_vector[i]) # Proportion for this individual
# Generating random indices to introduce missing data for this individual
missing_indices <- sample(individual_entries, num_missing, replace = FALSE)
# Convert these indices to account for the individual's two chromosomes
missing_rows <- rep((i * num_chromosomes - num_chromosomes + 1):(i * num_chromosomes), each = num_missing)
missing_cols <- sort(rep(missing_indices, num_chromosomes))
# Setting these indices to missing (".")
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
}
# Run this function without removing anything to update the missing data slot.
# object <- rmMissingData(object, 1)
return(object)
}
View(add_mnar(s, early_scenario))
ncol(s@sep_gt)
early_scenario <- c(rep(0.05, 5), rep(0.15, 4), rep(0.35, 4), rep(0.65, 3))
View(add_mnar(s, early_scenario))
add_mnar(s, early_scenario)
add_mnar <- function(object, missingness_vector) {
# Ensure that the missingness vector is of the same length as the number of individuals
if (length(missingness_vector) != ncol(object@sep_gt)/2) {
stop("The length of the missingness vector must be equal to the number of individuals.")
}
# Number of columns representing each individual (assuming diploid organism, should be 2)
num_chromosomes <- 2
for (i in seq_len(nrow(object@sep_gt)/num_chromosomes)) {
individual_entries <- nrow(object@sep_gt)/num_chromosomes # Number of entries for each chromosome of the individual
num_missing <- round(individual_entries * missingness_vector[i]) # Proportion for this individual
# Generating random indices to introduce missing data for this individual
missing_indices <- sample(individual_entries, num_missing, replace = FALSE)
# Convert these indices to account for the individual's two chromosomes
missing_rows <- rep((i * num_chromosomes - num_chromosomes + 1):(i * num_chromosomes), each = num_missing)
missing_cols <- sort(rep(missing_indices, num_chromosomes))
# Setting these indices to missing (".")
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
}
# Run this function without removing anything to update the missing data slot.
# object <- rmMissingData(object, 1)
return(object)
}
add_mnar(s, early_scenario)
add_mnar <- function(object, missingness_vector) {
# Ensure that the missingness vector is of the same length as the number of individuals
if (length(missingness_vector) != ncol(object@sep_gt)/2) {
stop("The length of the missingness vector must be equal to the number of individuals.")
}
# Number of columns representing each individual (assuming diploid organism, should be 2)
num_chromosomes <- 2
for (i in seq_len(ncol(object@sep_gt)/num_chromosomes)) {
individual_entries <- nrow(object@sep_gt)/num_chromosomes # Number of entries for each chromosome of the individual
num_missing <- round(individual_entries * missingness_vector[i]) # Proportion for this individual
# Generating random indices to introduce missing data for this individual
missing_indices <- sample(individual_entries, num_missing, replace = FALSE)
# Convert these indices to account for the individual's two chromosomes
missing_rows <- rep((i * num_chromosomes - num_chromosomes + 1):(i * num_chromosomes), each = num_missing)
missing_cols <- sort(rep(missing_indices, num_chromosomes))
# Setting these indices to missing (".")
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
}
# Run this function without removing anything to update the missing data slot.
# object <- rmMissingData(object, 1)
return(object)
}
add_mnar(s, early_scenario)
add_mnar <- function(object, missingness_vector) {
# Ensure that the missingness vector is of the same length as the number of individuals
if (length(missingness_vector) != ncol(object@sep_gt)/2) {
stop("The length of the missingness vector must be equal to the number of individuals.")
}
# Number of columns representing each individual (assuming diploid organism, should be 2)
num_chromosomes <- 2
for (i in seq_len(ncol(object@sep_gt)/num_chromosomes)) {
individual_entries <- nrow(object@sep_gt)/num_chromosomes # Number of entries for each chromosome of the individual
num_missing <- round(individual_entries * missingness_vector[i]) # Proportion for this individual
# Generating random indices to introduce missing data for this individual
missing_indices <- sample(individual_entries, num_missing, replace = FALSE)
# Convert these indices to account for the individual's two chromosomes
missing_cols <- rep((i * num_chromosomes - num_chromosomes + 1):(i * num_chromosomes), each = num_missing)
missing_rows <- sort(rep(missing_indices, num_chromosomes))
# Setting these indices to missing (".")
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
}
# Run this function without removing anything to update the missing data slot.
# object <- rmMissingData(object, 1)
return(object)
}
add_mnar(s, early_scenario)
x <- add_mnar(s, early_scenario)
View(x@sep_gt)
add_mnar <- function(object, missingness_vector) {
# Ensure that the missingness vector is of the same length as half the number of columns
if (length(missingness_vector) != ncol(object@sep_gt) / 2) {
stop("The length of the missingness vector must be equal to half the number of columns.")
}
# Number of columns representing each individual (assuming diploid organism, should be 2)
num_chromosomes <- 2
# Loop over each individual, which is represented by two columns (chromosomes)
for (i in seq_len(length(missingness_vector))) {
individual_entries <- nrow(object@sep_gt) # Number of rows is the same for each individual
num_missing <- round(individual_entries * missingness_vector[i]) # Proportion for this individual
# Generating random indices to introduce missing data for this individual
missing_rows <- sample(individual_entries, num_missing, replace = FALSE)
# Both columns (chromosomes) for the individual should have the same missing data
missing_cols <- rep((i * num_chromosomes - (num_chromosomes - 1)), times = num_missing)
# Setting these indices to missing (".") for both chromosomes
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
object@sep_gt[cbind(missing_rows, missing_cols + 1)] <- "."
}
return(object)
}
x <- add_mnar(s, early_scenario)
View(x@sep_gt)
add_mnar_categories <- function(object, category_definitions, individuals_per_category) {
# Check that the category definitions and individuals_per_category are correct
if (length(category_definitions) != length(individuals_per_category)) {
stop("Each category must have a corresponding number of individuals.")
}
num_individuals <- ncol(object@sep_gt) / 2
if (sum(individuals_per_category) > num_individuals) {
stop("The total number of individuals across categories exceeds the number of individuals in the dataset.")
}
# This will hold the proportion of missing data for each individual
missingness_vector <- rep(0, num_individuals)
# Assign individuals to categories
available_individuals <- 1:num_individuals
for (i in seq_along(category_definitions)) {
category <- category_definitions[[i]]
num_individuals_in_category <- individuals_per_category[i]
# Randomly choose individuals for this category
chosen_individuals <- sample(available_individuals, num_individuals_in_category)
available_individuals <- setdiff(available_individuals, chosen_individuals)
# Assign a random missing proportion within the category range to each chosen individual
for (individual in chosen_individuals) {
missingness_vector[individual] <- runif(1, category[1], category[2])
}
}
# Number of columns representing each individual (assuming diploid organism, should be 2)
num_chromosomes <- 2
# Apply missing data according to the generated missingness vector
for (i in seq_along(missingness_vector)) {
individual_entries <- nrow(object@sep_gt)
num_missing <- round(individual_entries * missingness_vector[i])
if (num_missing > 0) {
missing_rows <- sample(individual_entries, num_missing, replace = FALSE)
missing_cols <- rep((i * num_chromosomes - (num_chromosomes - 1)), each = num_missing)
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
object@sep_gt[cbind(missing_rows, missing_cols + 1)] <- "."
}
}
return(object)
}
x <- add_mnar_categories(genotype_data, category_definitions, individuals_per_category)
add_mnar <- function(object, category_definitions, individuals_per_category) {
# Check that the category definitions and individuals_per_category are correct
if (length(category_definitions) != length(individuals_per_category)) {
stop("Each category must have a corresponding number of individuals.")
}
num_individuals <- ncol(object@sep_gt) / 2
if (sum(individuals_per_category) > num_individuals) {
stop("The total number of individuals across categories exceeds the number of individuals in the dataset.")
}
# This will hold the proportion of missing data for each individual
missingness_vector <- rep(0, num_individuals)
# Assign individuals to categories
available_individuals <- 1:num_individuals
for (i in seq_along(category_definitions)) {
category <- category_definitions[[i]]
num_individuals_in_category <- individuals_per_category[i]
# Randomly choose individuals for this category
chosen_individuals <- sample(available_individuals, num_individuals_in_category)
available_individuals <- setdiff(available_individuals, chosen_individuals)
# Assign a random missing proportion within the category range to each chosen individual
for (individual in chosen_individuals) {
missingness_vector[individual] <- runif(1, category[1], category[2])
}
}
# Number of columns representing each individual (assuming diploid organism, should be 2)
num_chromosomes <- 2
# Apply missing data according to the generated missingness vector
for (i in seq_along(missingness_vector)) {
individual_entries <- nrow(object@sep_gt)
num_missing <- round(individual_entries * missingness_vector[i])
if (num_missing > 0) {
missing_rows <- sample(individual_entries, num_missing, replace = FALSE)
missing_cols <- rep((i * num_chromosomes - (num_chromosomes - 1)), each = num_missing)
object@sep_gt[cbind(missing_rows, missing_cols)] <- "."
object@sep_gt[cbind(missing_rows, missing_cols + 1)] <- "."
}
}
return(object)
}
# Define category ranges
category_definitions <- list(
Low = c(0, 0.05),
Moderate = c(0.05, 0.2),
High = c(0.2, 0.5),
Extreme = c(0.5, 0.8)
)
# Define the number of individuals per category
individuals_per_category <- c(
Low = 30,
Moderate = 15,
High = 10,
Extreme = 5
)
x <- add_mnar(genotype_data, category_definitions, individuals_per_category)
x <- add_mnar(s, category_definitions, individuals_per_category)
# Define the number of individuals per category
individuals_per_category <- c(
Low = 5,
Moderate = 4,
High = 4,
Extreme = 3
)
x <- add_mnar(s, category_definitions, individuals_per_category)
View(x@sep_gt)
data(real)
r <- calculateAlleleFreqs(r)
r <- calculateAlleleFreqs(real)
View(r@sep_gt)
