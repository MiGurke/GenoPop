% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/missing_data.R
\name{kNNImputation}
\alias{kNNImputation}
\title{kNNImputation}
\usage{
kNNImputation(
  vcf_path,
  output_vcf,
  k = 10,
  maxiter = 3,
  batch_size = 1000,
  threads = 1,
  write_log = FALSE,
  logfile = "logfile.txt"
)
}
\arguments{
\item{vcf_path}{Path to the input VCF file.}

\item{output_vcf}{Path for the output VCF file with imputed data.}

\item{k}{Number of nearest neighbors used for imputation (default: 10).}

\item{maxiter}{Maximum number of iterations for the kNN algorithm (default: 3).}

\item{batch_size}{Number of variants to process per batch (default: 1000).}

\item{threads}{Number of threads used for computation (default: 1).}

\item{write_log}{If TRUE, writes a log file of the process (advised for large datasets).}

\item{logfile}{Path to the log file, used if \code{write_log} is TRUE.}
}
\value{
Path to the output VCF file with imputed data.
}
\description{
Performs imputation of missing genomic data using a k-nearest-neighbor algorithm, optimized for large VCF files. This function reads VCF files in batches, applies kNN imputation, and writes the results to a new VCF file. It's designed for efficient processing through parallel computing and chunk-based handling of SNP data. The function uses the 'annoy' library for efficient neighbor detection. Note that neighboring SNPs lacking data will be excluded from the imputation process, and positions with large proportions of missing data may remain unimputed. The choice of batch size, number of neighbors (k), and the number of iterations (maxiter) is critical for balancing accuracy and computational demand.
}
\examples{
kNNImputation("/path/to/input.vcf",
              "/path/to/output.vcf",
              k = 10,
              maxiter = 3,
              batch_size = 1000,
              threads = 5,
              write_log = TRUE,
              logfile = "/path/to/logfile.txt")

}
